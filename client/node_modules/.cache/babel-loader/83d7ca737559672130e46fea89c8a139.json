{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar is = require('./is.js');\nvar token = require('./token.js');\nvar bl = require('./bl.js');\nvar common = require('./common.js');\nvar jump = require('./jump.js');\nvar byteUtils = require('./byte-utils.js');\nvar _0uint = require('./0uint.js');\nvar _1negint = require('./1negint.js');\nvar _2bytes = require('./2bytes.js');\nvar _3string = require('./3string.js');\nvar _4array = require('./4array.js');\nvar _5map = require('./5map.js');\nvar _6tag = require('./6tag.js');\nvar _7float = require('./7float.js');\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken: jump.quickEncodeToken\n};\nfunction makeCborEncoders() {\n  const encoders = [];\n  encoders[token.Type.uint.major] = _0uint.encodeUint;\n  encoders[token.Type.negint.major] = _1negint.encodeNegint;\n  encoders[token.Type.bytes.major] = _2bytes.encodeBytes;\n  encoders[token.Type.string.major] = _3string.encodeString;\n  encoders[token.Type.array.major] = _4array.encodeArray;\n  encoders[token.Type.map.major] = _5map.encodeMap;\n  encoders[token.Type.tag.major] = _6tag.encodeTag;\n  encoders[token.Type.float.major] = _7float.encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new bl.Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(\"\".concat(common.encodeErrPrefix, \" object contains circular references\"));\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new token.Token(token.Type.null, null),\n  undefined: new token.Token(token.Type.undefined, undefined),\n  true: new token.Token(token.Type.true, true),\n  false: new token.Token(token.Type.false, false),\n  emptyArray: new token.Token(token.Type.array, 0),\n  emptyMap: new token.Token(token.Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new token.Token(token.Type.float, obj);\n    } else if (obj >= 0) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new token.Token(token.Type.break)];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [new token.Token(token.Type.array, obj.length), entries, new token.Token(token.Type.break)];\n    }\n    return [new token.Token(token.Type.array, obj.length), entries];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new token.Token(token.Type.break)];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [objectToTokens(key, options, refStack), objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [new token.Token(token.Type.map, length), entries, new token.Token(token.Type.break)];\n    }\n    return [new token.Token(token.Type.map, length), entries];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[\"\".concat(typ, \"Array\")] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let refStack = arguments.length > 2 ? arguments[2] : undefined;\n  const typ = is.is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(\"\".concat(common.encodeErrPrefix, \" unsupported type: \").concat(typ));\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new bl.Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(\"Unexpected error: pre-calculated length for \".concat(tokens, \" was wrong\"));\n      }\n      return byteUtils.asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexports.Ref = Ref;\nexports.encode = encode;\nexports.encodeCustom = encodeCustom;\nexports.makeCborEncoders = makeCborEncoders;\nexports.objectToTokens = objectToTokens;","map":{"version":3,"names":["Object","defineProperty","exports","value","is","require","token","bl","common","jump","byteUtils","_0uint","_1negint","_2bytes","_3string","_4array","_5map","_6tag","_7float","defaultEncodeOptions","float64","mapSorter","quickEncodeToken","makeCborEncoders","encoders","Type","uint","major","encodeUint","negint","encodeNegint","bytes","encodeBytes","string","encodeString","array","encodeArray","map","encodeMap","tag","encodeTag","float","encodeFloat","cborEncoders","buf","Bl","Ref","constructor","obj","parent","includes","p","createCheck","stack","Error","concat","encodeErrPrefix","simpleTokens","null","Token","undefined","true","false","emptyArray","emptyMap","typeEncoders","number","_typ","_options","_refStack","Number","isInteger","isSafeInteger","bigint","BigInt","Uint8Array","boolean","_obj","ArrayBuffer","DataView","buffer","byteOffset","byteLength","Array","options","refStack","length","addBreakTokens","break","entries","i","e","objectToTokens","typ","isMap","keys","size","key","get","sortMapEntries","Map","Buffer","split","arguments","customTypeEncoder","tokens","typeEncoder","sort","e1","e2","keyToken1","isArray","keyToken2","type","compare","tcmp","compareTokens","console","warn","tokensToEncoded","encodeCustom","data","quickBytes","encoder","encodedSize","chunks","asU8A","reset","toBytes","encode","assign"],"sources":["C:/6th sem/bc/Crime-Records-Blockchain/client/node_modules/cborg/cjs/lib/encode.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar is = require('./is.js');\nvar token = require('./token.js');\nvar bl = require('./bl.js');\nvar common = require('./common.js');\nvar jump = require('./jump.js');\nvar byteUtils = require('./byte-utils.js');\nvar _0uint = require('./0uint.js');\nvar _1negint = require('./1negint.js');\nvar _2bytes = require('./2bytes.js');\nvar _3string = require('./3string.js');\nvar _4array = require('./4array.js');\nvar _5map = require('./5map.js');\nvar _6tag = require('./6tag.js');\nvar _7float = require('./7float.js');\n\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken: jump.quickEncodeToken\n};\nfunction makeCborEncoders() {\n  const encoders = [];\n  encoders[token.Type.uint.major] = _0uint.encodeUint;\n  encoders[token.Type.negint.major] = _1negint.encodeNegint;\n  encoders[token.Type.bytes.major] = _2bytes.encodeBytes;\n  encoders[token.Type.string.major] = _3string.encodeString;\n  encoders[token.Type.array.major] = _4array.encodeArray;\n  encoders[token.Type.map.major] = _5map.encodeMap;\n  encoders[token.Type.tag.major] = _6tag.encodeTag;\n  encoders[token.Type.float.major] = _7float.encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new bl.Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ common.encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new token.Token(token.Type.null, null),\n  undefined: new token.Token(token.Type.undefined, undefined),\n  true: new token.Token(token.Type.true, true),\n  false: new token.Token(token.Type.false, false),\n  emptyArray: new token.Token(token.Type.array, 0),\n  emptyMap: new token.Token(token.Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new token.Token(token.Type.float, obj);\n    } else if (obj >= 0) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new token.Token(token.Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new token.Token(token.Type.array, obj.length),\n        entries,\n        new token.Token(token.Type.break)\n      ];\n    }\n    return [\n      new token.Token(token.Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new token.Token(token.Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new token.Token(token.Type.map, length),\n        entries,\n        new token.Token(token.Type.break)\n      ];\n    }\n    return [\n      new token.Token(token.Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is.is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ common.encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new bl.Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return byteUtils.asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\n\nexports.Ref = Ref;\nexports.encode = encode;\nexports.encodeCustom = encodeCustom;\nexports.makeCborEncoders = makeCborEncoders;\nexports.objectToTokens = objectToTokens;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}